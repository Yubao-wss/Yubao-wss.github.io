---
layout: post
title: Java多线程
categories:
  - ACM
  - Template
tags: Posts
date: 2021-06-01 14:00:00
---

### Java之多线程

#### 进程与线程

- ##### 进程

  进程是**程序的一次动态执行过程**，它需要经历从代码加载，代码执行到执行完毕的一个完整的过程，这个过程也是进程本身从产生，发展到最终消亡的过程。多进程操作系统能同时达运行多个进程（程序），由于 CPU 具备分时机制，所以**每个进程都能【循环】获得自己的CPU 时间片**。由于 CPU 执行速度非常快，使得所有程序**好像是在同时**运行一样 

- ##### 线程

  线程是比进程更小的执行单位，**线程是进程的基础之上进行进一步的划分**。所谓多线程是指一个进程在执行过程中可以产生多个更小的程序单元，这些更小的单元称为线程，这些线程可以**同时存在，同时运行**，一个进程可能包含多个同时执行的线程 

  比如两个处理文件的程序A、B同时在执行，CPU会循环给它们俩时间片，A执行一会，再换B；A是一个多线程程序，分两个线程，分别从文件开头和文件结尾处理，B则是单线程；最终A会以快于B一倍的速度执行完


#### 多线程的作用

更充分的利用CPU的资源，以提高程序运行的效率

PS：只有多核CPU才能实现真正的多线程，一个CPU(核)在同一时间，只能分配给一个线程

#### 线程的创建

##### 继承Thread类

继承Thread类，重写run方法，在main方法（主线程）中调用该类对象 的start方法，即可实现多线程同时执行

```java
public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("This is my thread " + i);
        }
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();

        for (int i = 0; i < 20; i++) {
            System.out.println("This is main thread " + i);
        }
    }
}
```

##### 实现Runnable接口

实现Runnable接口，重写run方法；调用Thread类的构造方法，并以实现Runnable接口的类的对象作为参数；调用Thread类对象的start方法

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("This is my thread " + i);
        }
    }

    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();

        new Thread(myRunnable).start();

        for (int i = 0; i < 20; i++) {
            System.out.println("This is main thread " + i);
        }
        
        //lambda表达式写法
        Runnable runnable = ()->{
            for (int i = 0; i < 20; i++) {
                System.out.println("This is my thread " + i);
            }
        };
        new Thread(runnable).start();
    }
}
```

PS：此方式底层是通过【静态代理模式】实现的

PS：Lambda表达式，一种语法糖，用于简化函数式接口的实现

```java
public class TestLambda {
    public static void main(String[] args) {
        //普通调用
        ILike like = new Like();
        like.lambda();

        //匿名内部类调用
        like = new ILike() {
            @Override
            public void lambda() {
                System.out.println("normal use");
            }
        };
        like.lambda();


        //lambda简化
        like = ()->{
            System.out.println("use lambda is good");
        };
        like.lambda();

        //有参数时
        ILove iLove = (int a)->{
            System.out.println(a);
        };
        iLove.lambda(1);

        //简化类型
        iLove = (a)->{
            System.out.println(a);
        };

        //简化括号 参数=1
        iLove = a->{
            System.out.println(a);
        };

        //简化花括号 方法体=1行
        iLove = a-> System.out.println(a);
    }
}

interface ILike{
    void lambda();
}

class Like implements ILike{
    @Override
    public void lambda() {
        System.out.println("i like lambda");
    }
}

interface ILove{
    void lambda(int a);
}
```

##### 实现Callable接口

实现Callable接口，重写call方法，call方法必须有一个返回值，并且与Callable声明的泛型类型一致

```java
public class MyCallable implements Callable<Boolean> {
    @Override
    public Boolean call() {
        for (int i = 0; i < 20; i++) {
            System.out.println("This is my thread " + i);
        }
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable myCallable = new MyCallable();

        //创建执行服务
        ExecutorService ser = Executors.newFixedThreadPool(1);
        //提交执行
        Future<Boolean> future = ser.submit(myCallable);

        //获取返回结果
        Boolean b = future.get();

        System.out.println("myCallable result is " + b);
    
        ser.shutdown();
    }
}
```

#### 线程状态

![线程状态](F:\Github\Yubao-wss.github.io\public\image\线程状态.jpg)

##### 线程停止

run方法执行完，执行它的线程就会自己停止；若想让线程被手动停止，推荐使用标志位法，如下：

```java
public class TestStop implements Runnable {
    //1、定义标志位
    private boolean flag = true;

    @Override
    public void run() {
        //2、方法体使用该标识
        while (flag){
            System.out.println("run thread");
        }
    }

    //3、对外提供方法改变标识
    public void stop(){
        this.flag = false;
        System.out.println("stop this thread");
    }

    public static void main(String[] args) throws InterruptedException {
        TestStop testStop = new TestStop();
        new Thread(testStop).start();
        //主线程暂停2s
        Thread.sleep(2000);
        testStop.stop();
    }
}
```

PS：线程终止后（进入死亡状态）就不能再次通过start方法重启了，即线程只能启动一次

##### 线程休眠

线程休眠通过Thread类的静态方法**sleep**实现

- sleep(xx)指定当前线程阻塞的毫秒数

  Thread.sleep()出现在方法体中，当前线程指的是正在调用该方法的线程

- sleep存在InterruptedException

- sleep时间达到后线程进入就绪状态

- sleep可以**模拟网络延迟**，倒计时等

- sleep不会释放锁

##### 线程礼让

通过Thread类的静态方法**yield**实现

- 将线程从运行状态转为可运行状态（就绪状态）
- 能够让当前正在执行的线程暂停，但不阻塞
- 礼让后，CPU会重新调度，该线程可能又被选中，故可能出现“礼让失败”的状况

```java
public class TestYield {
    public static void main(String[] args) {
        MyYield myYield = new MyYield();

        for (int i = 0; i < 10; i++) {
            new Thread(myYield, "a").start();
            new Thread(myYield, "b").start();
        }
    }
}

class MyYield implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "线程开始执行");
        Thread.yield();
        System.out.println(Thread.currentThread().getName() + "线程停止执行");
    }
}
```

##### 线程合并

通过Thread类的静态方法**join**实现

下面程序执行的效果是：

一开始主线程与joinThread线程同步执行，当主线程循环到200并执行joinThread.join()后，控制台只有joinThread线程在输出，直到joinThread输出完，主线程再输出后面的内容；即执行joinThread.join()后，主线程进入了阻塞状态

```java
public class TestJoin implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("join thread " + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        TestJoin testJoin = new TestJoin();
        Thread joinThread = new Thread(testJoin);
        joinThread.start();

        for (int i = 0; i < 500; i++) {
            if(i == 200){
                joinThread.join();
            }
            System.out.println("main thread" + i);
        }
    }
}
```

##### 查看线程状态

通过Thread类的实例方法**getState**获取

```java 
public class TestState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("thread over");
        });

        Thread.State state = thread.getState();
        System.out.println(state);

        thread.start();
        state = thread.getState();
        System.out.println(state);

        //线程不终止 打印状态
        while (state != Thread.State.TERMINATED){
            Thread.sleep(100);
            state = thread.getState();
            System.out.println(state);
        }
    }
}
```

#### 并发问题

当多个线程操作同一个资源的情况下，会造成数据的紊乱，如买票问题

```java
public class Ticket implements Runnable {

    private int ticketNums = 10;

    @Override
    public void run() {
        while(true){
            if(ticketNums <= 0){
                break;
            }
            ticketNums--;
            System.out.println(Thread.currentThread().getName() + "拿到了第" + ticketNums + "张票");
        }
    }

    public static void main(String[] args) {
        Ticket ticket = new Ticket();

        new Thread(ticket, "sam").start();
        new Thread(ticket, "mike").start();
        new Thread(ticket, "waston").start();
    }
}
```

会出现一张票被多个人买或少卖票的情况

**原因**：若线程1的System.out.println卡在线程2的ticketNums--和System.out.println的中间执行，导致一张票被卖了两次；同时，也会有一张票“消失”